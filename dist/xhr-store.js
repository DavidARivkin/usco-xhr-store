// Generated by CoffeeScript 1.9.1
var Minilog, Q, XHRStore, XMLHttpRequest, detectEnv, logger,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

detectEnv = require("composite-detect");

Q = require("q");

if (detectEnv.isModule) {
  Minilog = require("minilog");
  Minilog.pipe(Minilog.suggest).pipe(Minilog.backends.console.formatClean).pipe(Minilog.backends.console);
  logger = Minilog('xhr-store');
}

if (detectEnv.isNode) {
  XMLHttpRequest = require("xhr2").XMLHttpRequest;
  Minilog.pipe(Minilog.suggest).pipe(Minilog.backends.console.formatColor).pipe(Minilog.backends.console);
}

if (detectEnv.isBrowser) {
  XMLHttpRequest = window.XMLHttpRequest;
  Minilog.pipe(Minilog.suggest).pipe(Minilog.backends.console.formatClean).pipe(Minilog.backends.console);
  logger = Minilog('xhr-store');
}

XHRStore = (function() {
  function XHRStore(options) {
    this._request = bind(this._request, this);
    this.stats = bind(this.stats, this);
    this.read = bind(this.read, this);
    this.list = bind(this.list, this);
    this.logout = bind(this.logout, this);
    this.login = bind(this.login, this);
    var defaults;
    options = options || {};
    defaults = {
      enabled: (typeof process !== "undefined" && process !== null ? true : false),
      name: "XHR",
      description: "",
      rootUri: typeof process !== "undefined" && process !== null ? process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE : null,
      isDataDumpAllowed: false,
      showPaths: true
    };
    this.timeout = 3000;
  }

  XHRStore.prototype.login = function() {};

  XHRStore.prototype.logout = function() {};


  /*-------------------file/folder manipulation methods---------------- */


  /**
  * list all elements inside the given uri (non recursive)
  * @param {String} uri the folder whose content we want to list
  * @return {Object} a promise, that gets resolved with the content of the uri
   */

  XHRStore.prototype.list = function(uri) {
    var deferred;
    deferred = Q.defer();
    return deferred;
  };


  /**
  * read the file at the given uri, return its content
  * @param {String} uri absolute uri of the file whose content we want
  * @param {String} encoding the encoding used to read the file
  * @return {Object} a promise, that gets resolved with the content of file at the given uri
   */

  XHRStore.prototype.read = function(uri, encoding, responseType) {
    var mimeType;
    encoding = encoding || 'utf8';
    mimeType = 'text/plain; charset=x-user-defined';
    logger.debug("reading from " + uri);
    return this._request(uri, "GET", mimeType, responseType);
  };


  /**
  * get the size of the file at the given uri
  * @param {String} uri absolute uri of the file whose size we want
  * @return {Object} a promise, that gets resolved with the content of file at the given uri
  Ã©
   */

  XHRStore.prototype.stats = function(uri) {
    var deferred, error, request;
    logger.debug("getting file size from " + uri);
    deferred = Q.defer();
    try {
      request = new XMLHttpRequest();
      Q["catch"](deferred.promise, function() {
        return request.abort();
      });
      request.open("HEAD", uri, true);
      request.onreadystatechange = function() {
        if (request.readyState === request.DONE) {
          return deferred.resolve(parseInt(request.getResponseHeader("Content-Length")));
        }
      };
      request.send();
    } catch (_error) {
      error = _error;
      deferred.reject(error);
    }
    return deferred;
  };


  /*-------------------Helpers---------------- */

  XHRStore.prototype._request = function(uri, type, mimeType, responseType) {
    var deferred, encoding, error, onError, onLoad, onProgress, onTimeOut, request;
    type = type || "GET";
    mimeType = mimeType || null;
    encoding = encoding || 'utf8';
    responseType = responseType || null;
    logger.debug("sending xhr2 request: " + type + " " + mimeType + " " + encoding + " " + responseType);
    deferred = Q.defer();
    try {
      request = new XMLHttpRequest();
    } catch (_error) {
      error = _error;
      deferred.reject("Failed to create xmlhttp request");
    }
    Q["catch"](deferred.promise, function() {
      return request.abort();
    });
    onLoad = (function(_this) {
      return function(event) {
        var result;
        if (event != null) {
          result = event.target.response || event.target.responseText;
          return deferred.resolve(result);
        } else {
          throw new Error("no event data");
        }
      };
    })(this);
    onProgress = (function(_this) {
      return function(event) {
        var percentComplete;
        if (event.lengthComputable) {
          percentComplete = (event.loaded / event.total) * 100;
          logger.debug("fetching percent", percentComplete);
          return deferred.notify({
            "fetching": percentComplete,
            "total": event.total
          });
        }
      };
    })(this);
    onError = (function(_this) {
      return function(event) {
        logger.error("error", event);
        error = "";
        switch (request.status) {
          case 404:
            error = "Uri not found";
            break;
          default:
            error = "Unknown error";
        }
        return deferred.reject(error);
      };
    })(this);
    onTimeOut = (function(_this) {
      return function(event) {
        logger.error("timeout", event);
        return deferred.reject("Timed out while fetching data from uri");
      };
    })(this);
    try {
      request.open(type, uri, true);
      if ((mimeType != null) && (request.overrideMimeType != null)) {
        logger.debug("support for setting mimetype");
        request.overrideMimeType(mimeType);
      }
      request.timeout = this.timeout;
      request.responseType = responseType;
      request.addEventListener('load', onLoad, false);
      request.addEventListener('loadend', onLoad, false);
      request.addEventListener('progress', onProgress, false);
      request.addEventListener('error', onError, false);
      request.addEventListener('timeout', onTimeOut, false);
      request.send();
    } catch (_error) {
      error = _error;
      deferred.reject(error);
    }
    return deferred;
  };

  return XHRStore;

})();

if (detectEnv.isModule) {
  module.exports = XHRStore;
}
