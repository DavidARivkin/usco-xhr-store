// Generated by CoffeeScript 1.6.3
'use strict';
var Q, XHRStore, XMLHttpRequest, isNode, logger, path,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Q = require("q");

path = require("path");

isNode = typeof global !== "undefined" && {}.toString.call(global) === '[object global]';

if (isNode) {
  XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
} else {
  XMLHttpRequest = window.XMLHttpRequest;
}

logger = require("./logger.coffee");

logger.level = "critical";

XHRStore = (function() {
  function XHRStore(options) {
    this._request = __bind(this._request, this);
    this.stats = __bind(this.stats, this);
    this.read = __bind(this.read, this);
    this.list = __bind(this.list, this);
    this.logout = __bind(this.logout, this);
    this.login = __bind(this.login, this);
    var defaults;
    options = options || {};
    defaults = {
      enabled: (typeof process !== "undefined" && process !== null ? true : false),
      name: "XHR",
      type: "",
      description: "",
      rootUri: typeof process !== "undefined" && process !== null ? process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE : null,
      isDataDumpAllowed: false,
      showPaths: true
    };
    /*
    #FIXME@vent.on("project:saved",@pushSavedProject)
    */

  }

  XHRStore.prototype.login = function() {};

  XHRStore.prototype.logout = function() {};

  /*-------------------file/folder manipulation methods----------------*/


  /**
  * list all elements inside the given uri (non recursive)
  * @param {String} uri the folder whose content we want to list
  * @return {Object} a promise, that gets resolved with the content of the uri
  */


  XHRStore.prototype.list = function(uri) {
    var deferred;
    deferred = Q.defer();
    return deferred.promise;
  };

  /**
  * read the file at the given uri, return its content
  * @param {String} uri absolute uri of the file whose content we want
  * @param {String} encoding the encoding used to read the file
  * @return {Object} a promise, that gets resolved with the content of file at the given uri
  */


  XHRStore.prototype.read = function(uri, encoding) {
    encoding = encoding || 'utf8';
    return this._request(uri);
  };

  XHRStore.prototype.stats = function(uri) {
    var deferred, request;
    deferred = Q.defer();
    request = new XMLHttpRequest();
    request.open("HEAD", uri, true);
    request.onreadystatechange = function() {
      if (this.readyState === this.DONE) {
        return deferred.resolve(parseInt(request.getResponseHeader("Content-Length")));
      }
    };
    request.send();
    return deferred.promise;
  };

  XHRStore.prototype._request = function(uri, type, mimeType) {
    var deferred, encoding, onError, onLoad, onProgress, request,
      _this = this;
    type = type || "GET";
    mimeType = mimeType || 'text/plain; charset=x-user-defined';
    encoding = encoding || 'utf8';
    deferred = Q.defer();
    request = new XMLHttpRequest();
    request.open("GET", uri, true);
    if (mimeType != null) {
      request.overrideMimeType(mimeType);
    }
    onLoad = function(event) {
      var result;
      result = event.target.response || event.target.responseText;
      return deferred.resolve(result);
    };
    onProgress = function(event) {
      var percentComplete;
      if (event.lengthComputable) {
        percentComplete = (event.loaded / event.total) * 100;
        logger.debug("percent", percentComplete);
        return deferred.notify({
          "download": percentComplete,
          "total": event.total
        });
      }
    };
    onError = function(event) {
      return deferred.reject(event);
    };
    request.addEventListener('load', onLoad, false);
    request.addEventListener('loadend', onLoad, false);
    request.addEventListener('progress', onProgress, false);
    request.addEventListener('error', onError, false);
    request.send();
    return deferred.promise;
  };

  return XHRStore;

})();

module.exports = XHRStore;
