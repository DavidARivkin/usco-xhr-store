// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var Minilog, Q, XHRStore, XMLHttpRequest, detectEnv, logger, path,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  detectEnv = require("composite-detect");

  Q = require("q");

  path = require("path");

  if (detectEnv.isModule) {
    Minilog = require("minilog");
    Minilog.pipe(Minilog.suggest).pipe(Minilog.backends.console.formatClean).pipe(Minilog.backends.console);
    logger = Minilog('xhr-store');
  }

  if (detectEnv.isNode) {
    XMLHttpRequest = require("xhr2").XMLHttpRequest;
    Minilog.pipe(Minilog.suggest).pipe(Minilog.backends.console.formatColor).pipe(Minilog.backends.console);
  }

  if (detectEnv.isBrowser) {
    XMLHttpRequest = window.XMLHttpRequest;
    Minilog.pipe(Minilog.suggest).pipe(Minilog.backends.console.formatClean).pipe(Minilog.backends.console);
    logger = Minilog('xhr-store');
  }

  XHRStore = (function() {
    function XHRStore(options) {
      this._request = __bind(this._request, this);
      this.stats = __bind(this.stats, this);
      this.read = __bind(this.read, this);
      this.list = __bind(this.list, this);
      this.logout = __bind(this.logout, this);
      this.login = __bind(this.login, this);
      var defaults;

      options = options || {};
      defaults = {
        enabled: (typeof process !== "undefined" && process !== null ? true : false),
        name: "XHR",
        type: "",
        description: "",
        rootUri: typeof process !== "undefined" && process !== null ? process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE : null,
        isDataDumpAllowed: false,
        showPaths: true
      };
      this.timeout = 3000;
    }

    XHRStore.prototype.login = function() {};

    XHRStore.prototype.logout = function() {};

    /*-------------------file/folder manipulation methods----------------
    */


    /**
    * list all elements inside the given uri (non recursive)
    * @param {String} uri the folder whose content we want to list
    * @return {Object} a promise, that gets resolved with the content of the uri
    */


    XHRStore.prototype.list = function(uri) {
      var deferred;

      deferred = Q.defer();
      return deferred.promise;
    };

    /**
    * read the file at the given uri, return its content
    * @param {String} uri absolute uri of the file whose content we want
    * @param {String} encoding the encoding used to read the file
    * @return {Object} a promise, that gets resolved with the content of file at the given uri
    */


    XHRStore.prototype.read = function(uri, encoding, responseType) {
      var mimeType;

      encoding = encoding || 'utf8';
      mimeType = 'text/plain; charset=x-user-defined';
      logger.debug("reading from " + uri);
      return this._request(uri, "GET", mimeType, responseType);
    };

    /**
    * get the size of the file at the given uri
    * @param {String} uri absolute uri of the file whose size we want
    * @return {Object} a promise, that gets resolved with the content of file at the given uri
    Ã©
    */


    XHRStore.prototype.stats = function(uri) {
      var deferred, error, request;

      logger.debug("getting file size from " + uri);
      deferred = Q.defer();
      try {
        request = new XMLHttpRequest();
        request.open("HEAD", uri, true);
        request.onreadystatechange = function() {
          if (request.readyState === request.DONE) {
            return deferred.resolve(parseInt(request.getResponseHeader("Content-Length")));
          }
        };
        request.send();
      } catch (_error) {
        error = _error;
        deferred.reject(error);
      }
      return deferred.promise;
    };

    /*-------------------Helpers----------------
    */


    XHRStore.prototype._request = function(uri, type, mimeType, responseType) {
      var deferred, encoding, error, onError, onLoad, onProgress, onTimeOut, request,
        _this = this;

      type = type || "GET";
      mimeType = mimeType || null;
      encoding = encoding || 'utf8';
      responseType = responseType || null;
      logger.debug("sending xhr2 request: " + type + " " + mimeType + " " + encoding + " " + responseType);
      deferred = Q.defer();
      try {
        request = new XMLHttpRequest();
      } catch (_error) {
        error = _error;
        deferred.reject("Failed to create xmlhttp request");
      }
      onLoad = function(event) {
        var result;

        if (event != null) {
          result = event.target.response || event.target.responseText;
          return deferred.resolve(result);
        } else {
          throw new Error("no event data");
        }
      };
      onProgress = function(event) {
        var percentComplete;

        if (event.lengthComputable) {
          percentComplete = (event.loaded / event.total) * 100;
          logger.debug("percent", percentComplete);
          return deferred.notify({
            "download": percentComplete,
            "total": event.total
          });
        }
      };
      onError = function(event) {
        logger.error("error", event);
        error = "";
        switch (request.status) {
          case 404:
            error = "Uri not found";
            break;
          default:
            error = "Unknown error";
        }
        return deferred.reject(error);
      };
      onTimeOut = function(event) {
        logger.error("timeout", event);
        return deferred.reject("Timed out while fetching data from uri");
      };
      try {
        request.open(type, uri, true);
        if ((mimeType != null) && (request.overrideMimeType != null)) {
          logger.debug("support for setting mimetype");
          request.overrideMimeType(mimeType);
        }
        request.timeout = this.timeout;
        request.responseType = responseType;
        request.addEventListener('load', onLoad, false);
        request.addEventListener('loadend', onLoad, false);
        request.addEventListener('progress', onProgress, false);
        request.addEventListener('error', onError, false);
        request.addEventListener('timeout', onTimeOut, false);
        request.send();
      } catch (_error) {
        error = _error;
        defferred.reject(error);
      }
      return deferred.promise;
    };

    return XHRStore;

  })();

  if (detectEnv.isModule) {
    module.exports = XHRStore;
  }

}).call(this);
